# Name: Mert Kaan YILMAZ
# Number: 2381093

# Execution begins at adress 0
.pos 0
	irmovq Stack, %rsp      # Set stack pointer
	irmovq root, %rdi       # Set first parameter of the function
	irmovq array, %rsi      # Set rsi as second parameter 
	irmovq $8, %rdx         # Set rdx as third parameter 
	call collect_into       # Call max_btree(root)  
	irmovq $1, %r8
	addq %r8, %rax          # Index needs to be incremented by 1 at the end
	halt                    # Terminate the program

collect_into:               
	xorq %rax, %rax         # Set return value as 0
	andq %rdi, %rdi         # if (!root)
	je if_return            # else return 0;
	
check_len:
	irmovq $0, %r14         # Check Len
	subq %rdx, %r14         # if(array_len <= 0)
	jge if_return           # else return 0;
	                        
	
inside_else:
	pushq %rdi              # inside_else
	mrmovq 8(%rdi), %rdi    # root->left
	call collect_into       # call (root->left, ...)
	popq %rdi               # restore rdi
	rrmovq %rax, %r12
	rrmovq %rdx, %r8
	subq %r12, %r8          # if (left_len == array_len)
	je return_left_len
	
	mrmovq (%rdi), %r8
	
	xorq %r11, %r11         #
	addq %rsi, %r11         #
	addq %r12, %r11         #
	addq %r12, %r11         #
	addq %r12, %r11         # (array[left_len] = root->value;
	addq %r12, %r11         #
	addq %r12, %r11         #
	addq %r12, %r11         #
	addq %r12, %r11         #
	addq %r12, %r11         #
	rmmovq %r8, (%r11)      # 
	
	pushq %rdi              #
	pushq %rsi              #
	pushq %rdx              # Save previous variables
	pushq %r12              #
	
	mrmovq 16(%rdi), %rdi   # root->right
	
	addq %r12, %rsi         #
	addq %r12, %rsi         #
	addq %r12, %rsi         #
	addq %r12, %rsi         #
	addq %r12, %rsi         #
	addq %r12, %rsi         #
	addq %r12, %rsi         #
	addq %r12, %rsi         #
	                        #  Setting second call parameters
	irmovq $1, %r8          #
	                        #
	addq %r8, %rsi          #
	addq %r8, %rsi          #
	addq %r8, %rsi          #
	addq %r8, %rsi          #
	addq %r8, %rsi          #
	addq %r8, %rsi          #
	addq %r8, %rsi          #
	addq %r8, %rsi          #
	
	subq %r12, %rdx         #
	subq %r8, %rdx          # array_len - left_len - 1
	
	call collect_into       # call for root->right
	rrmovq %rax, %r13
	
	popq %r12               #
	popq %rdx               #
	popq %rsi               # restore old variables
	popq %rdi               #
	
	
	xorq %rax, %rax         #
	addq %r12, %rax         #
	addq %r8, %rax          # return left_len + 1 + right_len;
	addq %r13, %rax         #
	ret                     #
	
if_return:
	xorq %rax, %rax
	ret
	
return_left_len:
	rrmovq %r12, %rax
	ret
	
# A sample eleven-element BST.
.pos 0x200
root:
	.quad 17
	.quad node6
	.quad node24
node6:
	.quad 6
	.quad node4
	.quad node11
node4:
	.quad 4
	.quad node3
	.quad node5
node3:
	.quad 3
	.quad 0
	.quad 0
node5:
	.quad 5
	.quad 0
	.quad 0
node11:
	.quad 11
	.quad node8
	.quad 0
node8:
	.quad 8
	.quad 0
	.quad 0
node24:
	.quad 24
	.quad node19
	.quad node40
node19:
	.quad 19
	.quad 0
	.quad 0
node40:
	.quad 40
	.quad 0
	.quad node52
node52:
	.quad 52
	.quad 0
	.quad 0
	

# A sample binary (not search!) tree
.pos 0x400
array:
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0


.pos 0x800
Stack:
