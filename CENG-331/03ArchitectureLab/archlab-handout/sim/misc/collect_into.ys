# Name: Mert Kaan YILMAZ
# Number: 2381093

# Execution begins at adress 0
.pos 0
	irmovq Stack, %rsp      # Set stack pointer
	irmovq root, %rdi       # Set first parameter of the function
	irmovq array, %rsi      # Set rsi as second parameter 
	irmovq $8, %rdx         # Set rdx as third parameter 
	call collect_into       # Call max_btree(root)  
	halt                    # Terminate the program

collect_into:
	xorq %rax, %rax         # Initialize return value as 0.
	andq %rdi, %rdi         # Check if root is empty. 
	je if_return            # if it is check other condition. 
	
check_len:
	irmovq $0, %r14         # Set register to compare.
	subq %rdx, %r14         # Check if array_len is <= 0.
	jge if_return           # Return 0 if array_len <= 0.
	                        # Else go into else part.
	
inside_else:
	pushq %rdi
	mrmovq 8(%rdi), %rdi    # root = root->value
	call collect_into
	popq %rdi
	rrmovq %rax, %r12
	rrmovq %rdx, %r8
	subq %r12, %r8
	je return_left_len
	mrmovq (%rdi), %r8
	
	xorq %r11, %r11         #
	addq %rsi, %r11         #
	addq %r12, %r11         #
	addq %r12, %r11         #
	addq %r12, %r11         # (array + left_len)
	addq %r12, %r11         #
	addq %r12, %r11         #
	addq %r12, %r11         #
	addq %r12, %r11         #
	addq %r12, %r11         #
	
	
	rmmovq %r8, (%r11)      # array[left_len] = root->value;
	
	pushq %rdi
	pushq %rsi
	pushq %rdx
	
	mrmovq 16(%rdi), %rdi
	
	addq %r12, %rsi
	addq %r12, %rsi
	addq %r12, %rsi
	addq %r12, %rsi
	addq %r12, %rsi
	addq %r12, %rsi
	addq %r12, %rsi
	addq %r12, %rsi
	
	irmovq $1, %r8
	
	addq %r8, %rsi
	addq %r8, %rsi
	addq %r8, %rsi
	addq %r8, %rsi
	addq %r8, %rsi
	addq %r8, %rsi
	addq %r8, %rsi
	addq %r8, %rsi
	
	subq %r12, %rdx
	subq %r8, %rdx
	
	call collect_into
	rrmovq %rax, %r13
	popq %rdx
	popq %rsi # belki gerek yok??
	popq %rdi
	
	
	irmovq $0, %rax
	addq %r12, %rax
	addq %r8, %rax
	addq %r13, %rax

	ret
	
if_return:
	irmovq $0, %rax
	ret
	
return_left_len:
	rrmovq %r12, %rax
	ret
	
# A sample eleven-element BST.
.pos 0x200
root:
	.quad 17
	.quad node6
	.quad node24
node6:
	.quad 6
	.quad node4
	.quad node11
node4:
	.quad 4
	.quad node3
	.quad node5
node3:
	.quad 3
	.quad 0
	.quad 0
node5:
	.quad 5
	.quad 0
	.quad 0
node11:
	.quad 11
	.quad node8
	.quad 0
node8:
	.quad 8
	.quad 0
	.quad 0
node24:
	.quad 24
	.quad node19
	.quad node40
node19:
	.quad 19
	.quad 0
	.quad 0
node40:
	.quad 40
	.quad 0
	.quad node52
node52:
	.quad 52
	.quad 0
	.quad 0
	

# A sample binary (not search!) tree
.pos 0x400
array:
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0


.pos 0x800
Stack:
